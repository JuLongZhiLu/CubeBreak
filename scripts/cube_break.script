local function create_shockwave(pos)
	-- 1. 在爆炸位置创建冲击波模型
	local shock_id = factory.create("#shockwave_factory", pos)

	-- 2. 初始状态：极小
	go.set_scale(vmath.vector3(0.1, 0.1, 0.1), shock_id)

	-- 3. 动画：迅速变大
	-- 这里的 10, 10, 10 是最终大小，你可以根据方块大小调整
	go.animate(shock_id, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(50, 50, 50), go.EASING_OUTCIRC, 0.3)

	-- 4. 动画：渐隐（需要模型的材质有 tint 属性）
	-- 假设模型组件 ID 是 "model"
	local model_url = msg.url(nil, shock_id, "model")

	-- 将透明度(w分量)从 1 变到 0
	go.animate(model_url, "tint.w", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_OUTQUAD, 0.3, 0, function()
		go.delete(shock_id) -- 动画结束删除
	end)
end

-- 建议将效果函数写在外面或上方，保持逻辑清晰
local function break_effect(self)
	local pos = go.get_position() 

	create_shockwave(pos) -- <--- 调用冲击波
	
	local fragment_num = 12        -- 稍微增加一点碎片

	-- 【动画 1】：方块消失前的视觉反馈
	-- 让当前方块先瞬间放大再缩小消失，产生“炸开”的前奏感
	go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(1.2, 1.2, 1.2), go.EASING_OUTQUAD, 0.1, 0, function()
		go.set_scale(vmath.vector3(0.01,0.01,0.01)) -- 炸完完全隐藏
	end)

	for i = 1, fragment_num do
		local fragment_id = factory.create("#fragment_factory", pos)

		-- 随机大小
		local random_s = math.random(15, 35) / 100
		go.set_scale(vmath.vector3(random_s, random_s, random_s), fragment_id)

		-- 【动画 2】：随机初始旋转（让碎片角度各异）
		local rand_rot = vmath.vector3(math.random(0,360), math.random(0,360), math.random(0,360))
		go.set(fragment_id, "euler", rand_rot)

		-- 计算随机力
		local force_x = math.random(-600, 600)
		local force_y = math.random(500, 900) 
		local force_z = math.random(-600, 600)
		local force_vec = vmath.vector3(force_x, force_y, force_z)

		-- 施加冲量
		local collision_url = msg.url(nil, fragment_id, "collisionobject")
		msg.post(collision_url, "apply_impulse", {
			impulse = force_vec * random_s,
			position = pos
		})

		-- 【动画 3】：碎片飞行过程中的旋转（翻滚感）
		-- 让碎片在 2 秒内随机翻滚几圈
		go.animate(fragment_id, "euler", go.PLAYBACK_ONCE_FORWARD, rand_rot * 2, go.EASING_LINEAR, 2)

		-- 【动画 4】：自动清理 + 缩放消失动画
		-- 碎片不是突兀消失，而是慢慢变小
		local delay = 1.0 + math.random() -- 随机 1-2 秒后开始消失
		go.animate(fragment_id, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(0,0,0), go.EASING_INBACK, 0.5, delay, function()
			go.delete(fragment_id)
		end)
	end
end

function init(self)
	math.randomseed(os.time())
	msg.post("#break0", "enable")
	msg.post("#break1", "disable")
	msg.post("#break2", "disable")
	msg.post(".", "acquire_input_focus")
	self.click_count = 0
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		self.click_count = self.click_count + 1

		if self.click_count == 1 then
			msg.post("#break0", "disable")
			msg.post("#break1", "enable")
			-- 给 break1 来个轻微的点击震动效果
			go.set_scale(vmath.vector3(1.1, 0.9, 1.1)) -- 压扁一点点
			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(1,1,1), go.EASING_OUTELASTIC, 0.3)

		elseif self.click_count == 2 then
			msg.post("#break1", "disable")
			msg.post("#break2", "enable")
			-- 颜色变红（如果你的材质有 tint 属性）
			-- go.set("#break2", "tint", vmath.vector4(1, 0.5, 0.5, 1))
			go.set_scale(vmath.vector3(1.1, 0.9, 1.1)) -- 压扁一点点
			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(1,1,1), go.EASING_OUTELASTIC, 0.3)

		elseif self.click_count == 3 then
			-- 触发爆炸函数
			break_effect(self)
			-- 延迟一点点关掉 break2，配合消失动画
			timer.delay(0.1, false, function()
				msg.post("#break2", "disable")
			end)
		end
	end
end